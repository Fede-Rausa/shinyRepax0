[{"name":"app.R","content":"\n\n\n# import libraries -----\nlibrary(shiny)\nlibrary(shinyjs)\nlibrary(bslib)\nlibrary(plotly)\nlibrary(ggplot2)\nlibrary(ggcorrplot)\nlibrary(tidyr)\nlibrary(dplyr)\nlibrary(DT)\n#library(gridExtra)\n\n\n\n# Define UI  ----\nui <- page_sidebar(\n  useShinyjs(),  # Set up shinyjs\n  \n  title = \"Repax Burger (|)\",  #set title\n  \n  sidebar = sidebar(\n    selectInput(\"mode\", \"modalità: \", \n                c(\"panoramica serie\",\n                  \"dati grezzi\", \n                  \"istruzioni\",\n                  \"intervalli\",\n                  \"correlazioni\", \n                  \"regressione\", \n                  \"previsione\", \n                  \"prezzo ottimo\")),\n    \n    selectInput(\"opzioniPiatti\", 'trova prezzo per piatto', choices = NULL),    \n    sliderInput(\"costo\", \"costo unitario del piatto:\",\n                min = 0, max = 5, step=0.1, value = 1),    \n    \n    \n    selectInput(\"cormode\", \"tipo di correlazione \", c(\"pearson\", \"spearman\")),\n    \n    selectInput(\"dtab\", \"vedi \", c(\"distribuzione\", \"conf-intervals\")),\n    sliderInput(\"PVinput\", \"confidence interval (IC) level:\",\n                min = 0.001, max = 0.5, step=0.001, value = 0.05),\n    \n    sliderInput(\"ninput\", \"Number of numeric input variables:\",\n                min = 1, max = 3, step=1, value = 1),\n    \n    uiOutput(\"inputOptionN\"),\n    \n    sliderInput(\"dinput\", \"Number of binary input variables:\",\n                min = 0, max = 10, step=1, value = 0),\n    \n    uiOutput(\"inputOptionD\"),\n    uiOutput(\"inputOptionN1\"),\n    uiOutput(\"inputOptionD1\"),\n    \n    checkboxInput(\"filtriP\", \"filtro piatti\", FALSE),\n    checkboxInput(\"filtriA\", \"filtro anni\", FALSE),\n    checkboxInput(\"filtriG\", \"filtro giorni\", FALSE),\n    checkboxInput(\"selectall\", \"seleziona tutti\", FALSE),\n    checkboxGroupInput(\"filtriPiatti\",\"filtra dataset per piatti\",c()),\n    checkboxGroupInput(\"filtriAnni\",\"filtra dataset per anni\",c()),\n    checkboxGroupInput(\"filtriGiorni\",\"filtra dataset per giorni feriali\",c()),\n    \n    checkboxInput(\"contorni\", \"solo contorni\", FALSE),\n    checkboxInput(\"panini\", \"solo panini\", FALSE)\n    \n  ),\n  \n  card(id='card_serie', \n       card_header(class = \"bg-dark\",\n                   \"manuale d'uso per REPAX BURGER\"),\n       \n       card_body(\n         fill=F,\n         card_title(\"A cosa serve?\"),\n         markdown(\"\n         La funzione di quest'app è quella di osservare e analizzare rapidamente i\n         dati della paninoteca dell'oratorio Regina Pacis, al fine di: \n         <br>-prevedere le quantità vendute, in totale e giorno per giorno, di ogni piatto\n         <br>-fissare i prezzi dei panini\n         <br>-capire quali panini rendono di più, e quali non rendono affatto\n         (anche considerando il costo degli ingredienti e il profitto finale per piatto)\n         <br><br>\n         Il menù a tendina 'modalità' consente di passare per le diverse funzionalità.\n         Le opzioni 'panoramica serie' e 'dati grezzi' servono per guardare rapidamente\n         il dati raccolti in Repax dal 2021 al 2023 (in una settimana di ottobre dal lunedì al venerdì).\n         L'opzione 'intervalli' è forse la più utile, perché consente di stimare il range\n         delle vendite/quantità vendute di **un piatto** in **una sera** (la variabile Q del dataset) in modo molto affidabile.\n         Le tre opzioni 'regressione', 'previsione' e 'prezzo ottimo' sono collegate dal filo conduttore\n         della regressione lineare, che è un modello utile per prevedere Q\n         in una sera dato il prezzo, il piatto e il giorno, e correggere anche i dati distorti\n         da situazioni eccezionali (come il covid nel 2021, che ha portato vendite inferiori agli standard).\n         <br>La modalità 'prezzo ottimo' utilizza il modello definito in 'regressione' per poi stimare i ricavi\n         e i profitti complessivi di una settimana.\n         <br>La modalità 'correlazioni' può servire a decidere quali piatti si vendono bene insieme (come le birre e le salamelle),\n         e quali invece si fanno concorrenza a vicenda (come i nuggets e i panzerotti).\n           \")\n       ),       \n       \n       \n       \n       card_body(\n         fill=F,\n         card_title(\"Info Utili\"),\n         markdown(\"\n         Altri dati su questo lavoro si possono trovare su [GitHub](https://github.com/Fede-Rausa/RepaxDatiPaninoteca)\n         <br>\n         La matematica e la logica di 'prezzo ottimo' è spiegata in questo [paper](https://github.com/Fede-Rausa/RepaxDatiPaninoteca/blob/main/PaniniProfitti.pdf)\n         <br>\n         L'app importa e analizza il seguente [dataset csv](https://raw.githubusercontent.com/Fede-Rausa/RepaxDatiPaninoteca/main/datiVendite.csv)\n           che si può anche aprire su Excel, GS, Rstudio e Python.\")\n       ),\n       \n       \n       card_body(\n         fill=F,\n         card_title(\"Dati Grezzi\"),\n         markdown(\"Si tratta semplicemente del dataset che viene elaborato dall'app.\n         <br>Un dataset è una tabella avente sulle colonne le variabili (come il prezzo dei panini) \n         e sulle righe le osservazioni (ad esempio la quantità venduta di patatine fuori dal menu il giovedì sera del 2023).\n         <br>Alcune variabili sono dummy, ovvero binarie 0-1, e indicano se un certo evento è accaduto (1) oppure no (0).\n         Ad esempio 'mar' è 1 il martedì, 0 altrimenti.\n         <br>Le dummy si possono dividere in 4 gruppi:\n         <br>- dummy dei giorni (lun-ven)\n         <br>- dummy degli anni (2021-2023)\n         <br>- dummy dei piatti\n         <br>- le dummy menu e contorno, che dicono se il piatto aveva lo sconto menu e se era un contorno \n         (ad esempio le piadine alla nutella sono un contorno ma non sempre sono nel menu)\n         \n         <br> Poi ci sono le variabili continue (numeri qualsiasi, in questo caso sempre positivi):\n         <br>- Q: vendite/quantità venduta (variabile y da prevedere nella regressione)\n         <br>- P: prezzo (var indipendente)\n         <br>- ggn: giorno, da 1 a 5 (da lun a ven) (var indipendente)\n         <br>- annon: anno, da 1 a 3 (2021-2023)  (var indipendente)\n           \")\n       ),\n       \n       card_body(\n         fill=F,\n         card_title(\"Panoramica Serie\"),\n         markdown(\"Consente di osservare l'evoluzione temporale\n         delle quantità vendute di ciascun piatto, su tre anni.\n         <br>\n         La variabile tempo non è proporzionale con il tempo\n         relamente trascorso, serve solo a visualizzare facilmente la serie.\n         <br> tale variabile è il risultato di questa formula:\"),\n         withMathJax(\"$$tempo = ggn + annon*7$$\"),\n         markdown(\"\n         dove ggn e annon sono descritte sopra. annon viene moltiplicato per 7 \n         perché si assume che il numero massimo di serate di paninoteca corrisponde alla durata della settimana (negli anni può cambiare, ma resta sotto tale soglia).\n         <br>\n         Per controllare le date, i nomi dei piatti, il prezzo di vendita,\n         se sono contorni scontati nel menu o meno,\n         passarci sopra col mouse.\n         <br>\n         <br>Per rimuovere o aggiungere una serie, cliccare una volta sul rispettivo nome a lato. \n         <br>Per selezionare o deselezionare tutte le serie tranne una, fare doppio click sul suo nome a lato.\n         <br>Con gli strumenti in alto puoi anche zoomare o scaricare il grafico.\n           \")\n       ),\n       \n       card_body(\n         fill=F,\n         card_title(\"Intervalli\"),\n         markdown(\"\n    Questa funzione può sembrare molto tecnica e noiosa, ma è la più utile se si ha la pazienza per capirla.\n    Presenta un istogramma di frequenza, che misura quanto è probabile che la variabile Q assuma un certo valore.\n    <br> puoi scegliere quali valori di Q osservare, utilizzando i filtri (per piatti, giorni, anni) sulla sidebar.\n    In sintesi, presenta la distribuzione marginale di probabilità della variabile Q.\n    Se non sai (come è facile che sia) cosa sia una distribuzione di probabilità, cerca di capirlo su Internet.\n    <br>Oltre all'istogramma si presentano:\n    <br>- le statistiche descrittive di Q (media, deviazione standard e i tre quantili/percentili\n    (i valori di Q minimi tra i più alti, rispettivamente, del 25%/50%/75% delle osservazioni di Q))\n    <br>- gli intervalli di confidenza (ovvero i range entro cui cade più probabilmente Q) basati su tre diverse funzioni\n    di densità di probabilità (la densità kernel è molto larga, la poisson molto stretta, la normale media)\n    \n    <br>Una 'funzione di densità' è una cosa complicata, associata alla distribuzione di probabilità. Ogni distribuzione ha la sua densità.\n    In modo poco ortodosso, si può interpretare come la funzione che, dato un valore di Q, e date la media e la deviazione standard di Q, dice quanto è probabile che Q assuma quel valore.\n    Comunque puoi cercare di capire su Internet anche questo.\n    <br>La ragione per cui si sono scelte le densità kernel, Poisson e Normale sono le seguenti:\n    <br>- la densità kernel non è associata a nessuna distribuzione di probabilità, e può essere utilizzata sempre.\n    <br>- la densità Normale, per il Teorema del Limite Centrale di Gauss, può descrivere qualsiasi fenomeno in natura.\n    <br>- la densità Poisson, definita per valori numerici interi positivi (come i volumi di vendita), è la più adatta a descrivere l'andamento di Q, e il grafico lo conferma.\n           \n    <br> Infine, è possibile allargare o ridurre gli intervalli di confidenza (delle tre densità), \n    riducendo o aumentando il 'livello di confidenza', che si può in modo poco ortodosso interpretare come la (massima) \n    probabilità che Q cada fuori dal range. Di default la probabilità che Q cada nel range è del 95%, e quindi il livello di confidenza è del 5%.       \n             \")\n       ),\n       \n       card_body(\n         fill=F,\n         card_title(\"Correlazioni\"),\n         markdown(\" \n             Correlazione delle quantità vendute dei diversi piatti.<br> \n             E' utile se si vuole capire quali piatti si fanno concorrenza \n             a vicenda (beni sostituti) e quali invece si vendono insieme (beni complementi). \n             <br>La correlazione è un valore che va da -1 \n             (dipendenza negativa, ovvero trade-off: al crescere di una variabile decresce l'altra) \n             a 1 (dipendenza positiva, ovvero crescono insieme), \n             e in valore assoluto (modulo) da 0 (totale indipendenza) \n             a 1 (massima dipendenza).\n             <br>Una differenza significativa tra la correlazione di Pearson \n             (solo lineare) e la correlazione di Spearman \n             (in genere più alta in modulo) \n             può significare che esiste una relazione non lineare \n             (quindi poliniomiale, esponenziale o logaritmica) \n             tra le variabili correlate. \n             Attenzione: le correlazioni NA sono state sostituite da 0 \n             (si assumono indipendenti ma in realtà non si sono \n             mai visti insieme).\n             \")\n       ),\n       \n       card_body(\n         fill=F,\n         card_title(\"Regressione\"),\n         markdown(\"Un modello di regressione lineare è una funzione del tipo:\"),\n         \n         withMathJax('$$y = b_0 + b_1*x_1 + b_2*x_2 + ... + b_k*x_k$$'),\n         \n         \n         markdown(\"Dove nel nostro caso y è Q (vogliamo prevedere la quantità venduta)\n             , le diverse x sono le altre variabili (dummy o continue, tra cui il prezzo P),\n             e i b sono parametri stimati dal modello che azzerano la **media** degli errori.\n             <br> la regressione lineare può diventare polinomiale se si aggiungono\n             uno o più regressori elevati a una certa potenza (continui, in quanto le dummy (0 o 1) non cambiano con le potenze), come ad esempio il modello:\"),\n         withMathJax('$$y = b_0 + b_1*x_1 + b_2*x_1^2 + b_3*x_2$$'),\n         \n         markdown(\"\n             Sostanzialmente, in questa modalità noi scegliamo quali regressori usare\n             per costruire la regressione. \n             <br> Come verificare se il modello funziona bene? Vi sono vari modi:\n             <br>- controlla il coefficiente del regressore P (prezzo): se è positivo, significa che il tuo\n             modello ritiene che al crescere del prezzo crescano le vendite, cosa del tutto falsa.\n             <br>- controlla il MAE (mean absolute error): se sembra alto, non va bene.\n             <br>- controlla i p-value dei test t sui coefficienti della regressione:\n             questi p-value rappresentano (in modo poco ortodosso) la (massima) probabilità che il coefficiente b associato\n             sia pari a 0, e quindi sono tanto più alti quanto peggiore è la scelta di quella variabile come regressore \n             (valori accettabili dei p-value sui test t sono minori di 0.1)\n             <br>- controlla la mediana (median) dei residui (errori fatti dal modello su tutte le osservazioni di Q):\n             se la mediana non è vicina a 0 si può fare di meglio.\n             \n             <br> Ho verificato che il mio modello funziona male. Come costruisco una regressione migliore? Vi sono 2 modi:\n             <br>1 - puoi filtrare il dataset con dati diversi (usando i filtri nella sidebar)\n             <br>2 - puoi cambiare/aggiungere regressori (buona scelta sono P, le dummy dei giorni e year2021)\n             \")\n       ),\n       \n       card_body(\n         fill=F,\n         card_title(\"Previsione\"),\n         markdown(\"Consente semplicemente di calcolare le previsioni di Q con il modello di regressione scelto.\n             Fa anche un bel grafico in cui si vede quanto è buono l'adattamento ai dati della retta di regressione. (variando solo P sulle ascisse)\"\n         )\n       ), \n       \n       card_body(\n         fill=F,\n         card_title(\"Esempio su come fare una buona regressione\"),\n         markdown(\"\n    Poniamo ad esempio di voler prevedere la quantità venduta di salamelle.\n    Se usiamo tutti i dati, e cerchiamo di prevederle in funzione del solo prezzo, avremo un pessimo modello,\n    con un coefficiente del prezzo positivo. In questo caso possiamo utilizzare due tipi di soluzioni:\n    \n    <br>- soluzione easy: vado nei filtri, e rimuovo tutti i piatti diversi dalle salamelle. Il modello con il solo prezzo è buono.\n    \n    <br>-soluzione pro: vado nei filtri, e rimuovo tutti i piatti tranne salamella, cotto, vegeta e speck (sono prodotti che, almeno in teoria, dovrebbero essere simili dal punto di vista dei clienti). Poi aggiungo come regressori le seguenti dummy: \n    il piatto salamella (che viene venduto generalmente di più), quattro dummy sui giorni (da mar a ven), la dummy year2021 (che è stato un anno più basso).\n    Il modello che ne esce è fantastico.\n             \")\n       ),   \n       \n       card_body(\n         fill=F,\n         card_title(\"Prezzo Ottimo\"),\n         markdown(\"\n                 \n             \n             Ultima ma prima per importanza, questa modalità ci consente di stimare\n             il bilancio complessivo di un certo piatto. \n             <br>A fronte del modello di regressione stimato, e del costo unitario fissato dall'utente (il costo in € \n             che devi sostenere per cucinare una singola porzione di quel piatto), si utilizza un ottimizzatore numerico\n             per massimizzare il profitto complessivo su tutti i giorni presenti nel dataset (si possono rimuovere alcuni giorni utilizzando i soliti filtri sulla sidebar).\n             L'ottimizzatore numerico cerca di fissare un prezzo ottimo nel range da 0.1€ a 10€.\n             <br>Di solito, se la soluzione trovata è circa ~ 9.99€\n             significa che il modello ha stimato un coefficiente di regressione b per P (prezzo) positivo (per cui prevede che al crescere del prezzo aumentano le vendite).\n             <br>è quindi ragionevole, in questo caso, modificare il modello di regressione o filtrare il dataset, finché il coefficente di P non diventa negativo.\n             <br>\n             ATTENZIONE: a causa di un bug per recepire le modifiche sui filtri bisogna aprire il foglio 'previsione' prima di usare l'ottimizzatore.\n             \"\n         )\n       )    \n       \n  ), \n  \n  \n  textOutput(\"introreg\"),\n  \n  textOutput(\"formula\"),\n  \n  DT::dataTableOutput(\"tavola\"),\n  \n  textOutput(\"corintro\"),\n  tags$head(tags$style(\"#corintro{ font-size: 10px; font-style: italic; }\")),\n  \n  plotlyOutput(outputId = \"serie\", height=\"85%\"),\n  \n  plotOutput(outputId = \"cormat\"),\n  plotOutput(outputId = \"Qhist\"),\n  \n  \n  textOutput(\"ttest\"),\n  tags$head(tags$style(\"#ttest{ font-size: 10px; font-style: italic; }\")),\n  tabPanel(\"pvalues dei test t\", verbatimTextOutput(\"pvt\")),\n  \n  textOutput(\"titolo\"),\n  \n  tabPanel(\"prevedo\", verbatimTextOutput(\"previsione\")),\n  \n  tabPanel(\"distribution\", verbatimTextOutput(\"DIST\")),\n  \n  tabPanel(\"myprofit\", verbatimTextOutput(\"profitto\")),\n  \n  plotOutput(outputId = \"scenario\")\n  \n)\n\n\n\n# define server ------\n\nserver <- function(input, output, session) {\n  \n  # funzioni utili ----\n  catToDummy = function(cat){\n    unici = unique(cat)\n    mat = matrix(numeric(length(cat)*length(unici)), ncol=length(unici))\n    \n    for (i in 1:ncol(mat)){\n      mat[,i] = ifelse(cat == unici[i],1,0)\n    }\n    colnames(mat) = unici\n    return(mat)\n  }\n  \n  #scrivi la formula di regressione\n  exprFormula = function(reg, output, xnames){\n    #testo della funzione\n    #frm = formula(reg)\n    #frm = Reduce(paste, deparse(frm))\n    segni = ifelse(coef(reg)>0, \" + \",\"\")\n    coeftext = paste(segni, as.character(round(coef(reg), 3)) , sep='')\n    coeftext = paste(coeftext, c(1,xnames), sep=' * ')\n    intext = paste(coeftext, collapse = \"\")\n    frm = paste(output, \"=\", intext)\n    return(frm)\n  }\n  \n  #prevedi una sequenza data una continua in un range e le altre fissate\n  iperpred = function(reg, varinput, varcostanti, valcostanti, min=0, max=10, step=0.1){\n    varia = seq(min,max,step)\n    df3 = matrix(rep(valcostanti, length(varia)), ncol=length(valcostanti),byrow=T)\n    df3 = as.data.frame(cbind(df3, varia))\n    colnames(df3) = c(varcostanti, varinput)\n    fit = predict(reg, df3)\n    return(list(y = fit, x = varia))\n  }\n  \n  #grafica iperpred\n  multiregplot = function(df,reg,output, input, costNames,costValues,min,max,step){\n    res = iperpred(reg, input,costNames,costValues, min = min, max = max, step=step)\n    plot(df[[input]], df[[output]], xlab = input, ylab=output, \n         ylim = c(min(min(res$y),min(df[[output]])), \n                  max(max(res$y), max(df[[output]]))) , \n         xlim = c(min(min(res$x),min(df[[input]])), \n                  max(max(res$x), max(df[[input]]))), \n         col = \"blue\")\n    lines(res$x,res$y, col='red')\n  }\n  \n  \n  #scrivi la formula di regressione\n  exprFormula = function(reg, output, xnames){\n    #testo della funzione\n    #frm = formula(reg)\n    #frm = Reduce(paste, deparse(frm))\n    segni = ifelse(coef(reg)>0, \"+\",\"\")\n    coeftext = paste(segni, as.character(round(coef(reg), 3)) , sep='')\n    coeftext = paste(coeftext, c(1,xnames), sep='*')\n    intext = paste(coeftext, collapse = \"\")\n    frm = paste(output, \"=\", intext)\n    return(frm)\n  }\n  \n  #fai una singola previsione, dato un modello e un vettore di input compatibile\n  minipred = function(reg, varcostanti, valcostanti){\n    df3 = as.data.frame(rbind(numeric(length(valcostanti)) , valcostanti))\n    colnames(df3) = varcostanti\n    fit = predict(reg, df3)[2]\n    return(fit)\n  }\n  \n  \n  #prevedi una sequenza data una continua in un range e le altre fissate\n  iperpred = function(reg, varinput, varcostanti, valcostanti, min=0, max=10, step=0.1){\n    varia = seq(min,max,step)\n    if (length(varcostanti)>0){\n      df3 = matrix(rep(valcostanti, length(varia)), ncol=length(valcostanti),byrow=T)\n      df3 = as.data.frame(cbind(df3, varia))\n      colnames(df3) = c(varcostanti, varinput)\n    }else{\n      df3 = data.frame(varia)\n      colnames(df3) = varinput\n    }\n    fit = predict(reg, df3)\n    return(list(y = fit, x = varia))\n  }\n  \n  minipred = function(reg, varcostanti, valcostanti){\n    df3 = as.data.frame(rbind(numeric(length(valcostanti)) , valcostanti))\n    colnames(df3) = varcostanti\n    fit = predict(reg, df3)[2]\n    residui = summary(reg$residuals)\n    mae = mean(abs(reg$residuals))\n    names(fit) = \"stima quantità venduta in una sera\"\n    names(mae) = \"MAE: mean absolute error\"\n    return(c(fit, mae))\n  }\n  \n  #grafica iperpred\n  multiregplot = function(df,reg,output, input, costNames,costValues,min,max,step){\n    res = iperpred(reg, input,costNames,costValues, min = min, max = max, step=step)\n    plot(df[[input]], df[[output]], xlab = input, ylab=output, \n         ylim = c(min(min(res$y),min(df[[output]])), \n                  max(max(res$y), max(df[[output]]))) , \n         xlim = c(min(min(res$x),min(df[[input]])), \n                  max(max(res$x), max(df[[input]]))), \n         col = \"blue\")\n    lines(res$x,res$y, col='red')\n  }\n  \n  \n  \n  \n  #crea un modello di regressione polinomiale multivariata con o senza dummy\n  hypeReg = function(df, output, rdummy, rcontinui, gradi){\n    \n    df3 = df[,c(output, rcontinui, rdummy)]\n    \n    xnames = c() #per la formula visibile\n    inames = c() #per la formula invisibile\n    \n    for (i in 1:length(rcontinui)){\n      for (j in 1:gradi[i]){\n        if (j>1){\n          xnames=c(xnames,paste(rcontinui[i],\"^\", as.character(j), sep=\"\"))\n          inames=c(inames, paste(\"I(\", rcontinui[i],\"^\", as.character(j),\")\"))\n        }\n        else{\n          xnames=c(xnames,rcontinui[i])\n          inames=c(inames,rcontinui[i])\n        }\n      }\n    }\n    \n    xnames = c(xnames, rdummy)\n    inames = c(inames, rdummy)\n    \n    reg = lm(reformulate(inames, output), data = df3)\n    \n    return(list(reg=reg,xnames=xnames))\n  }\n  \n  \n  \n  \n  \n  # funzioni server ------  \n  \n  \n  ##mostra e filtra il dataset\n  aggiornaDF = function(){\n    #applica filtri\n    selezione1 = input$filtriPiatti\n    selezione2 = input$filtriAnni\n    selezione3 = input$filtriGiorni\n    dfFilter = filter(dati, \n                      prod %in% selezione1,\n                      anno %in% selezione2,\n                      gg %in% selezione3)\n    output$tavola = DT::renderDataTable({dfFilter})\n  }\n  \n  \n  creaModello = function(){\n    #applica filtri\n    selezione1 = input$filtriPiatti\n    selezione2 = input$filtriAnni\n    selezione3 = input$filtriGiorni\n    dfreg = filter(dati, prod %in% selezione1, \n                   anno %in% selezione2,\n                   gg %in% selezione3)\n    \n    #raccogli dummy\n    catv = c(\"gg\", \"anno\", \"prod\")\n    dummyv = c(\"menu\", \"contorno\")\n    for (dum in catv){\n      newmat = catToDummy(dfreg[[dum]])\n      dummyv = c(dummyv, colnames(newmat))\n      dfreg = cbind(dfreg, newmat)\n    }\n    \n    #raccogli nomi e gradi continue (rimuovendo scelte duplicate)\n    NR = input$ninput\n    continui = numeric(NR)\n    polinomi = numeric(NR)\n    for (i in 1:NR){\n      nuovo = input[[paste0(\"regressore\",i)]]\n      if (!(nuovo %in% continui)){\n        continui[i] = nuovo\n        polinomi[i] = input[[paste0(\"grado\",i)]]      \n      }else{\n        continui[i] = NA\n      }\n    }\n    escludi = !is.na(continui)\n    continui = continui[escludi]\n    polinomi = polinomi[escludi]\n    \n    #raccogli nomi dummy (rimuovendo scelte duplicate)\n    ND = input$dinput\n    if (ND>0){\n      dummy = numeric(ND)\n      for (i in 1:ND){\n        nuovo = input[[paste0(\"dummy\",i)]]\n        if (!(nuovo %in% dummy)){\n          dummy[i] = nuovo\n        }else{\n          dummy[i] = NA\n        }\n      }\n      dummy = dummy[!is.na(dummy)]\n    }else{\n      dummy = c()\n    }\n    \n    model = hypeReg(dfreg, \"Q\", dummy, continui, polinomi)  \n    \n    return(list(model=model, df=dfreg, continui= continui, dummy=dummy))\n  }\n  \n  \n  \n  aggiornaReg = function(){\n    \n    scatola = creaModello()\n    model = scatola$model\n    continui = scatola$continui\n    dummy = scatola$dummy\n    dfreg = scatola$df\n    \n    #pvalues\n    #pvt0 = \"p-value dei t test sui coefficienti\"\n    pvt = summary(model$reg)$coefficients[,c(1,4)]\n    colnames(pvt) = c(\"stima coeff\", \"p-value (on t-test)\")\n    #colnames(pvt) = c(\"stima coeff\", pvt0)\n    \n    mae = mean(abs(model$reg$residuals))\n    names(mae)=\"MAE\"\n    sumres = list(c(summary(model$reg$residuals), mae))\n    names(sumres) = \"summary dei residui\"\n    outprint = list(pvt, sumres, regression_info = summary(model$reg)) #summary(model$reg) #list(pvt0, pvt)\n    \n    #formula\n    frm = exprFormula(model$reg, \"Q\", model$xnames)\n    \n    #mostra output\n    output$formula = renderText({frm})\n    output$pvt = renderPrint({outprint})\n    \n    #parte previsiva\n    \n    if (length(continui)>0){\n      valC = numeric(length(continui))\n      for (i in 1:length(continui)){\n        valC[i] = input[[paste0(\"valoreC\",i)]]\n      }}else{\n        valC = c()\n      }\n    \n    if (length(dummy)>0){\n      valD = numeric(length(dummy))\n      for (i in 1:length(dummy)){\n        valD[i] = input[[paste0(\"valoreD\",i)]]\n      }}else{\n        valD = c()\n      }\n    \n    \n    \n    varinput = continui[1]\n    varcostanti = c(continui[-1], dummy)\n    valcostanti = c(valC[-1], valD)\n    prediction = minipred(model$reg, c(continui,dummy), c(valC,valD))\n    \n    output$previsione = renderPrint({prediction})\n    \n    output$scenario = renderPlot({\n      multiregplot(dfreg, model$reg, \"Q\", \n                   varinput, varcostanti, valcostanti, \n                   min=0,max=6,step=0.1)\n    })\n    \n  }  \n  \n  \n  optimPrice = function(){\n    #calcolo prezzo ottimo\n    piatto = input$opzioniPiatti\n    costo = input$costo\n    \n    scatola = creaModello()\n    model = scatola$model\n    dfreg = scatola$df\n    continui = scatola$continui\n    dummy = scatola$dummy\n    \n    #raccogli valori dummy e continui da previsione\n    if (length(continui)>0){\n      valC = numeric(length(continui))\n      for (i in 1:length(continui)){\n        valC[i] = input[[paste0(\"valoreC\",i)]]\n      }}else{\n        valC = c()\n      }\n    \n    if (length(dummy)>0){\n      valD = numeric(length(dummy))\n      for (i in 1:length(dummy)){\n        valD[i] = input[[paste0(\"valoreD\",i)]]\n      }}else{\n        valD = c()\n      }  \n    \n    \n    \n    outprint0 = ottimizza1(model$reg, dfreg, costo, piatto, \n                           continui, dummy, valC, valD)\n    output$profitto = renderPrint({outprint0})\n  }\n  \n  #optimize one price\n  \n  ottimizza1 = function(reg, dati, costo, panino, \n                        continui=NULL, dummy=NULL, \n                        valcontinui=NULL, valdummy=NULL){\n    \n    id = which(dati[,panino]==1)\n    gg = unique(dati$gg)\n    ggn = unique(dati$ggn)\n    datiPanino = numeric(ncol(dati)*length(gg))%>%\n      matrix(ncol=ncol(dati)) %>% \n      as.data.frame()\n    colnames(datiPanino) = colnames(dati)\n    datiPanino$annon = 4\n    \n    #dummy piatti\n    datiPanino[,panino] = 1\n    \n    mybool = c('menu', 'contorno')\n    for (dum in mybool){\n      if (dum %in% dummy){\n        id = which(dummy ==dum)\n        if (valdummy[id]==1){\n          datiPanino[,dum]=1\n        }}}\n    \n    #dummy giorni\n    datiPanino$ggn = ggn\n    for (i in 1:length(gg)){\n      datiPanino[i,gg[i]] = 1\n    }\n    #dummy degli anni e degli altri piatti sono tutti nulli\n    \n    \n    daOttimizzare = function(prezzo){\n      datiPanino[,'P'] = prezzo\n      Qpanino = predict(reg, datiPanino)\n      costi = Qpanino*costo\n      ricavi = Qpanino*prezzo\n      profitti = ricavi-costi\n      profitto = sum(profitti)\n      return(profitto)\n    }\n    \n    otti = optimize(daOttimizzare, maximum=T, lower=0.05, upper=10)\n    bestP = otti$maximum\n    maxProfitto = otti$objective\n    \n    \n    prezzo = bestP\n    datiPanino[,'P'] = prezzo\n    Qpanino = predict(reg, datiPanino)\n    costi = Qpanino*costo\n    ricavi = Qpanino*prezzo\n    profitti = ricavi-costi\n    profitto = sum(profitti)\n    \n    debug = list(e0 = otti)\n    \n    mat = matrix(numeric((nrow(datiPanino)+1)*6),\n                 ncol=6) %>%as.data.frame()\n    colnames(mat) = c('prezzo1','costo1', 'Qvenduta', 'ricavi', 'costi', 'profitti')\n    rownames(mat) =c(gg, 'total')\n    mat$prezzo1 = prezzo\n    mat$costo1 = costo\n    mat$Qvenduta = c(Qpanino, sum(Qpanino))\n    mat$ricavi = c(ricavi, sum(ricavi))\n    mat$costi = c(costi, sum(costi))\n    mat$profitti = c(profitti, sum(profitti))\n    \n    if (coef(reg)['P']>0){\n      alert = matrix(c('il coefficiente del prezzo è positivo.  :(', \n                       'La previsione del prezzo ottimo può risultare vicina a 10 (il massimo)',\n                       'si consiglia di aggiustare meglio il modello di regressione',\n                       'ad esempio includendo le dummy dei giorni nei regressori',\n                       'oppure filtrando il dataset per i piatti più simili a quello studiato'), nrow=5)\n    }else{\n      alert = matrix(c('il coefficiente del prezzo è negativo  :)', \n                       'per cui la stima è verosimile (se inferiore a 9.9)'),\n                     nrow=2)\n    }  \n    \n    return(list(alert = alert, prezzo_ottimo = prezzo, profitto=profitto, \n                vendite_stimate = mat,\n                regressori_utilizzati = datiPanino[,-1]))\n  }\n  \n  \n  \n  \n  \n  # azioni server --------  \n  \n  #scrivi i testi\n  output$introreg = renderText({\"Modello di regressione lineare per prevedere Q (quantità venduta nel dataset filtrato)\"})\n  output$corintro = renderText({\n    \"Correlazione delle quantità vendute dei diversi piatti. E' utile se si vuole capire quali piatti si fanno concorrenza a vicenda (beni sostituti) e quali invece si vendono insieme (beni complementi).\n La correlazione è un valore che va da -1 (dipendenza negativa, ovvero trade-off: al crescere di una variabile decresce l'altra) a 1 (dipendenza positiva, ovvero crescono insieme),\ne in valore assoluto (modulo) da 0 (totale indipendenza) a 1 (massima dipendenza)\nUna differenza significativa tra la correlazione di Pearson (solo lineare) e la correlazione di Spearman (in genere più alta in modulo) può significare che esiste una relazione non lineare (quindi poliniomiale, esponenziale o logaritmica) tra le variabili correlate. \n Attenzione: le correlazioni NA sono state sostituite da 0 (si assumono indipendenti ma in realtà non si sono mai visti insieme).\n\"})\n  \n  output$ttest = renderText({\"Valori dei p-value dei test T sull'ipotesi nulla che i coefficienti delle variabili input siano pari a 0. \nSe il pvalue (del coefficiente) di una variabile è basso allora quella variabile input va tenuta, altrimenti va levata dal modello (in quanto non sono sufficientemente correlate e non aiuta a prevedere la variabile indipendente).\nAttenzione all'overfitting!! Se il numero di variabili è alto, le previsioni si adattano facilmente ai dati, ma ciò fa sembrare il modello migliore di quello che è.\"})\n  \n  \n  \n  \n  \n  #decidi se far comparire o meno gli elementi ui\n  observeEvent(input$mode, {\n    if (input$mode == \"panoramica serie\"){\n      show(\"contorni\")\n      show(\"panini\")\n      show(\"serie\")\n      \n      hide('card_serie')\n      hide('profitto')\n      hide('costo')\n      hide('opzioniPiatti')\n      hide('PVinput')\n      hide('dtab')\n      hide('DIST')\n      hide(\"Qhist\")   \n      hide(\"previsione\")\n      hide(\"scenario\")\n      hide('selectall')\n      hide(\"filtriP\")\n      hide(\"filtriPiatti\")\n      hide(\"filtriA\")\n      hide(\"filtriAnni\")\n      hide(\"filtriG\")\n      hide(\"filtriGiorni\")\n      hide(\"corintro\")\n      hide(\"cormat\")\n      hide(\"cormode\")\n      hide(\"tavola\")\n      hide(\"ninput\")\n      hide(\"inputOptionN\")\n      hide(\"dinput\")\n      hide(\"inputOptionD\")\n      hide(\"formula\")\n      hide(\"pvt\")\n      hide(\"ttest\")\n      hide(\"introreg\")\n      hide(\"inputOptionN1\")\n      hide(\"inputOptionD1\")\n    }\n    \n    if (input$mode == \"correlazioni\"){\n      hide(\"contorni\")\n      hide(\"panini\")\n      hide(\"serie\")\n      hide(\"ninput\")\n      hide(\"inputOptionN\")\n      hide(\"dinput\")\n      hide(\"inputOptionD\")\n      hide(\"tavola\")\n      hide(\"formula\")\n      hide(\"pvt\")\n      hide(\"ttest\")\n      hide(\"introreg\")\n      hide(\"inputOptionN1\")\n      hide(\"inputOptionD1\")\n      hide(\"previsione\")\n      hide(\"scenario\")\n      hide(\"Qhist\")\n      hide('DIST')\n      hide('dtab')\n      hide('PVinput')\n      hide('opzioniPiatti')\n      hide('profitto')\n      hide('costo')\n      hide('card_serie')\n      \n      show(\"filtriA\")\n      show(\"filtriP\")\n      show(\"filtriG\")\n      show(\"corintro\")\n      show(\"cormat\")\n      show(\"cormode\")\n    }\n    \n    if (input$mode == \"dati grezzi\"){\n      hide(\"contorni\")\n      hide(\"panini\")\n      hide(\"serie\")\n      hide(\"cormat\")\n      hide(\"corIntro\")\n      hide(\"cormode\")\n      hide(\"ninput\")\n      hide(\"inputOptionN\")\n      hide(\"dinput\")\n      hide(\"inputOptionD\")\n      hide(\"formula\")\n      hide(\"pvt\")\n      hide(\"ttest\")\n      hide(\"introreg\")\n      hide(\"inputOptionN1\")\n      hide(\"inputOptionD1\")\n      hide(\"previsione\")\n      hide(\"scenario\")\n      hide(\"Qhist\")   \n      hide('DIST')\n      hide('dtab')\n      hide('PVinput')\n      hide('opzioniPiatti')\n      hide('profitto')\n      hide('costo')\n      hide('card_serie')\n      \n      show(\"filtriA\")\n      show(\"filtriP\")\n      show(\"filtriG\")\n      show(\"tavola\")\n    }\n    \n    if (input$mode == \"regressione\"){\n      hide(\"contorni\")\n      hide(\"panini\")\n      hide(\"serie\")\n      hide(\"cormat\")\n      hide(\"corintro\")\n      hide(\"cormode\")\n      hide(\"tavola\")\n      hide(\"inputOptionN1\")\n      hide(\"inputOptionD1\")\n      hide(\"previsione\")\n      hide(\"scenario\")\n      hide(\"Qhist\")  \n      hide('DIST')\n      hide('dtab')\n      hide('PVinput')\n      hide('opzioniPiatti')\n      hide('profitto')\n      hide('costo')\n      hide('card_serie')\n      \n      show(\"formula\")\n      show(\"pvt\")\n      show(\"ttest\")\n      show(\"introreg\")\n      show(\"filtriA\")\n      show(\"filtriP\")\n      show(\"filtriG\")\n      show(\"ninput\")\n      show(\"inputOptionN\")\n      show(\"dinput\")\n      show(\"inputOptionD\")\n    }\n    \n    if (input$mode == \"previsione\"){\n      hide(\"contorni\")\n      hide(\"panini\")\n      hide(\"serie\")\n      hide(\"cormat\")\n      hide(\"corintro\")\n      hide(\"cormode\")\n      hide(\"tavola\")\n      hide(\"ninput\")\n      hide(\"inputOptionN\")\n      hide(\"dinput\")\n      hide(\"inputOptionD\")\n      hide(\"pvt\")\n      hide(\"ttest\")\n      hide(\"Qhist\")     \n      hide('DIST')\n      hide('dtab')\n      hide('PVinput')\n      hide('opzioniPiatti')\n      hide('profitto')\n      hide('costo')\n      hide('card_serie')\n      \n      show(\"formula\")\n      show(\"introreg\")\n      show(\"previsione\")\n      show(\"scenario\")\n      show(\"inputOptionN1\")\n      show(\"inputOptionD1\")\n      show(\"filtriA\")\n      show(\"filtriP\")\n      show(\"filtriG\")\n    }\n    \n    \n    \n    if (input$mode == \"intervalli\"){\n      hide(\"contorni\")\n      hide(\"panini\")\n      hide(\"serie\")\n      hide(\"cormat\")\n      hide(\"corintro\")\n      hide(\"cormode\")\n      hide(\"tavola\")\n      hide(\"ninput\")\n      hide(\"inputOptionN\")\n      hide(\"dinput\")\n      hide(\"inputOptionD\")\n      hide(\"pvt\")\n      hide(\"ttest\")\n      hide(\"formula\")\n      hide(\"introreg\")\n      hide(\"previsione\")\n      hide(\"scenario\")\n      hide(\"inputOptionN1\")\n      hide(\"inputOptionD1\")\n      hide('opzioniPiatti')\n      hide('profitto')\n      hide('costo')\n      hide('card_serie')\n      \n      show('PVinput')\n      show('dtab')\n      show('DIST')\n      show(\"Qhist\")\n      show(\"filtriA\")\n      show(\"filtriP\")\n      show(\"filtriG\")\n    }        \n    \n    if (input$mode == \"prezzo ottimo\"){\n      hide(\"contorni\")\n      hide(\"panini\")\n      hide(\"serie\")\n      hide(\"cormat\")\n      hide(\"corintro\")\n      hide(\"cormode\")\n      hide(\"tavola\")\n      hide(\"ninput\")\n      hide(\"inputOptionN\")\n      hide(\"dinput\")\n      hide(\"inputOptionD\")\n      hide(\"pvt\")\n      hide(\"ttest\")\n      hide(\"formula\")\n      hide(\"introreg\")\n      hide(\"previsione\")\n      hide(\"scenario\")\n      hide(\"inputOptionN1\")\n      hide(\"inputOptionD1\")\n      hide('PVinput')\n      hide('dtab')\n      hide('DIST')\n      hide(\"Qhist\")\n      hide('card_serie')\n      \n      show('profitto')\n      show('costo')\n      show('opzioniPiatti')\n      show(\"filtriA\")\n      show(\"filtriP\")\n      show(\"filtriG\")\n    }           \n    \n    \n    if (input$mode == \"istruzioni\"){\n      hide(\"contorni\")\n      hide(\"panini\")\n      hide(\"serie\")\n      hide(\"cormat\")\n      hide(\"corintro\")\n      hide(\"cormode\")\n      hide(\"tavola\")\n      hide(\"ninput\")\n      hide(\"inputOptionN\")\n      hide(\"dinput\")\n      hide(\"inputOptionD\")\n      hide(\"pvt\")\n      hide(\"ttest\")\n      hide(\"formula\")\n      hide(\"introreg\")\n      hide(\"previsione\")\n      hide(\"scenario\")\n      hide(\"inputOptionN1\")\n      hide(\"inputOptionD1\")\n      hide('PVinput')\n      hide('dtab')\n      hide('DIST')\n      hide(\"Qhist\")\n      hide('profitto')\n      hide('costo')\n      hide('opzioniPiatti')\n      hide(\"filtriA\")\n      hide(\"filtriP\")\n      hide(\"filtriG\")  \n      hide('selectall')\n      \n      show('card_serie')\n    }              \n    \n    \n    \n    \n    updateSelectInput(inputId='opzioniPiatti', choices=input$filtriPiatti)\n    \n    optimPrice() #calcola il prezzo ottimo\n    \n    aggiornaDF() #aggiorna dati grezzi\n    \n  })\n  \n  observeEvent(input$selectall,{\n    unici = unique(dati$prod)\n    if (input$selectall){\n      updateCheckboxGroupInput(session, \"filtriPiatti\", choices=unici, selected=unici)\n    }else{\n      updateCheckboxGroupInput(session, \"filtriPiatti\", choices=unici)\n    }\n  })\n  \n  \n  observeEvent(input$filtriPiatti,{\n    #fissa opzioni piatti in prezzo ottimo\n    updateSelectInput(inputId='opzioniPiatti', choices=input$filtriPiatti)\n    aggiornaDF() #aggiorna dati grezzi\n  }) \n  \n  \n  observeEvent(input$opzioniPiatti,{\n    #trova nuovo prezzo ottimo\n    optimPrice()\n  }) \n  \n  observeEvent(input$costo,{\n    #trova nuovo prezzo ottimo\n    optimPrice()\n  })  \n  \n  \n  observeEvent(input$filtriAnni,{\n    aggiornaDF() #aggiorna dati grezzi\n  })   \n  \n  observeEvent(input$filtriGiorni,{\n    aggiornaDF() #aggiorna dati grezzi\n  })  \n  \n  observe({\n    aggiornaReg() #crea le pagine previsione e regressione      \n  })\n  \n  \n  \n  #sistema i checkbox\n  observeEvent(input$panini, {\n    if (input$panini){\n      updateCheckboxInput(session, \"contorni\" , value = FALSE)\n    }\n  })\n  observeEvent(input$contorni, {\n    if (input$contorni){\n      updateCheckboxInput(session, \"panini\" , value = FALSE)\n    }\n  })\n  \n  \n  \n ####### #importa e correggi i dati\n  link = \"https://raw.githubusercontent.com/Fede-Rausa/RepaxDatiPaninoteca/main/datiVendite.csv\"   \n  dati = read.csv(link ,sep=\";\")\n  dati$P = as.numeric(gsub(\",\",\".\", dati$P))\n  dati = mutate(dati, prod0 = prod, \n                prod = paste(prod, ifelse(menu==1,\" M\",\"\"),sep=''),\n                annon = anno - 20,\n                anno = paste0(\"year\",anno + 2000))\n  \n  #nomi continue\n  numv = c(\"P\", \"annon\", \"ggn\")\n  #nomi categoriche\n  catv = c(\"gg\", \"anno\", \"prod0\")\n  dummyv = c(\"menu\", \"contorno\")\n  for (dum in catv){\n    dummyv = c(dummyv, unique(dati[[dum]]))\n  }\n  \n  #scegli regressori continui\n  output$inputOptionN = renderUI({\n    ninput = input$ninput\n    opzioni = numv\n    \n    lapply(1:ninput, \n           function(i){\n             fluidRow(\n               column(6, selectInput(inputId = paste0(\"regressore\", i),\n                                     label = paste(\"variabile \", i),\n                                     choices = opzioni)),\n               column(6, sliderInput(inputId = paste0(\"grado\", i),\n                                     label = \"input di grado\",\n                                     min = 1, max = 5, step=1, value = 1))\n             )})})\n  \n  #scegli regressori binari\n  output$inputOptionD = renderUI({\n    \n    selezione1 = input$filtriPiatti\n    selezione2 = input$filtriAnni\n    selezione3 = input$filtriGiorni\n    dati = filter(dati, \n                  prod %in% selezione1, \n                  anno %in% selezione2, \n                  gg %in% selezione3)\n    \n    catv = c(\"gg\", \"anno\", \"prod0\")\n    dummyv = c(\"menu\", \"contorno\")\n    for (dum in catv){\n      dummyv = c(dummyv, unique(dati[[dum]]))\n    }\n    \n    ninput = input$dinput\n    opzioni = dummyv\n    if (ninput>0){    \n      lapply(1:ninput, \n             function(i){\n               fluidRow(\n                 column(12, selectInput(inputId = paste0(\"dummy\", i),\n                                        label = paste(\"dummy \", i),\n                                        choices = opzioni)),\n               )})\n    }\n  })\n  \n  \n  #fissa regressori continui\n  output$inputOptionN1 = renderUI({\n    ninput = input$ninput\n    continui = numeric(ninput)\n    for (i in 1:ninput){\n      if (!(input[[paste0(\"regressore\",i)]]%in%continui)){\n        continui[i] = input[[paste0(\"regressore\",i)]]\n      }else{\n        continui[i] = NA\n      }\n    }\n    continui = continui[!is.na(continui)]\n    \n    if (length(continui)>0){\n      lapply(1:length(continui), \n             function(i){\n               fluidRow(\n                 column(12, sliderInput(inputId = paste0(\"valoreC\", i),\n                                        label = continui[i],\n                                        min = 1, max = 5, step=0.01, value = 1))\n               )})      \n    }\n  })\n  \n  #fissa regressori dummy\n  output$inputOptionD1 = renderUI({\n    dinput = input$dinput\n    dummy = numeric(dinput)\n    for (i in 1:dinput){\n      if (!(input[[paste0(\"dummy\",i)]]%in%dummy)){\n        dummy[i] = input[[paste0(\"dummy\",i)]]\n      }else{\n        dummy[i] = NA\n      }\n    }\n    dummy = dummy[!is.na(dummy)]\n    \n    if (length(dummy)>0){\n      lapply(1:length(dummy), \n             function(i){\n               fluidRow(\n                 column(12, sliderInput(inputId = paste0(\"valoreD\", i),\n                                        label = dummy[i],\n                                        min = 0, max = 1, step=1, value = 1))\n               )})     \n    }\n  })\n  \n  \n  \n  \n  \n  \n  #inizializza i filtri\n  observe({\n    updateCheckboxGroupInput(session, \"filtriPiatti\",\n                             choices = unique(dati$prod),\n                             selected = unique(dati$prod)\n    )\n    updateCheckboxGroupInput(session, \"filtriAnni\",\n                             choices = unique(dati$anno),\n                             selected = unique(dati$anno)\n    )\n    updateCheckboxGroupInput(session, \"filtriGiorni\",\n                             choices = unique(dati$gg),\n                             selected = unique(dati$gg)\n    )\n  })\n  \n  observeEvent(input$filtriP, {\n    if (input$filtriP){\n      show(\"filtriPiatti\")\n      show('selectall')\n    }else{\n      hide(\"filtriPiatti\")\n      hide('selectall')\n    }\n  })\n  observeEvent(input$filtriA, {\n    if (input$filtriA){\n      show(\"filtriAnni\")\n    }else{\n      hide(\"filtriAnni\")\n    }\n  })\n  observeEvent(input$filtriG, {\n    if (input$filtriG){\n      show(\"filtriGiorni\")\n    }else{\n      hide(\"filtriGiorni\")\n    }\n  })\n  \n  #fai il grafico\n  output$serie = renderPlotly({\n    id = dati$ggn + dati$annon * 7\n    \n    df = data.frame(time = id, q.venduta = dati$Q, punti=ifelse(dati$contorno==1,18,19),\n                    day = dati$gg, year=(dati$anno), \n                    prod0 = dati$prod, prezzo = paste(as.character(dati$P),\"€\"),\n                    prod = paste(dati$prod, ifelse(dati$menu==1,'M','') )  )\n    \n    #seleziona i dati del grafico\n    if (input$contorni){\n      df = df[which(dati$contorno==1),]\n    }\n    if (input$panini){\n      df = df[which(dati$contorno==0),]\n    }\n    \n    p <- ggplot(df,aes(price = prezzo, y = q.venduta , x = time,group=prod, col=prod,\n                       giorno = day, anno = year)) + \n      geom_point(shape=df$punti) + geom_line() +\n      theme_minimal()+ ggtitle(\"serie storica dei piatti venduti\") +\n      xlab(\"tempo\") + ylab(\"q. venduta\")\n    \n    ggplotly(p)\n  })\n  \n  \n  \n  \n  output$cormat = renderPlot({\n    \n    observeEvent(input$cormode,{})\n    \n    selezione1 = input$filtriPiatti\n    selezione2 = input$filtriAnni\n    selezione3 = input$filtriGiorni\n    \n    cormat = dati %>%\n      mutate(ggyear = paste(gg, anno, sep='-'))%>% \n      #mutate(prod = paste(prod, ifelse(menu==1,\" M\",\"\"),sep=''))%>%\n      filter(prod %in% selezione1, anno %in% selezione2, gg %in% selezione3) %>%\n      select(ggyear, prod, Q)%>% \n      pivot_wider(names_from = prod, values_from = Q) %>%\n      select(-ggyear) %>% \n      as.data.frame()%>%\n      cor(use=\"pairwise.complete.obs\", method=input$cormode)\n    \n    if (input$cormode==\"spearman\"){\n      titolo = \"correlazioni lineari e non tra le quantità vendute\"\n    }else{\n      titolo = \"correlazioni lineari tra le quantità vendute\"\n    }\n    \n    cormat[is.na(cormat)] = 0  \n    ggcorrplot(cormat, method =\"square\", hc.order = T, title=titolo)  # type='lower',\n  })\n  \n  \n  output$Qhist = renderPlot({\n    \n    selezione1 = input$filtriPiatti\n    selezione2 = input$filtriAnni\n    selezione3 = input$filtriGiorni\n    \n    qvet = dati %>%\n      filter(prod %in% selezione1, \n             anno %in% selezione2, \n             gg %in% selezione3) \n    \n    qvet = qvet$Q\n    N = length(qvet)\n    \n    hist(qvet, prob=T, \n         xlab='Q venduta in una sera di un piatto',\n         main='frequenze quantità venduta (da filtri)',\n         sub = paste0('distribuzione su ', N, ' osservazioni'))\n    lines(density(qvet), col='blue', lwd=2, lty='dashed')\n    ord = order(qvet)\n    lines(qvet[ord], dpois(qvet, mean(qvet))[ord], \n          col='darkred', lwd=2, lty='dashed')\n    lines(qvet[ord], dnorm(qvet, mean(qvet), sd(qvet))[ord], \n          col='purple', lwd=2, lty='dashed')\n    abline(v=mean(qvet), col='red', lwd=2)\n    abline(v=quantile(qvet, 0.5), col='orange', lwd=2)\n    abline(v=quantile(qvet, 0.25), col='green', lwd=2, lty='dotted')\n    abline(v=quantile(qvet, 0.75), col='green', lwd=2, lty='dotted')\n    \n    outprint = matrix(numeric(3*2), ncol=2)\n    colnames(outprint) = c('inf-IC', 'sup-IC')\n    rownames(outprint) = c('kernel', 'poisson', 'normale')\n    \n    IClevel = input$PVinput\n    Z = qnorm(1-IClevel/2)#1.96\n    med = mean(qvet)    \n    \n    dens = density(qvet)\n    outprint[1,] = quantile(dens$x, c(IClevel/2, 1-IClevel/2))\n    \n    errP = Z * sqrt(med/N)\n    ICpois = c(med- errP, med+ errP)\n    outprint[2,] = ICpois\n    \n    errN = Z * sd(qvet)/sqrt(N)\n    ICnorm = c(med- errN, med+ errN)\n    outprint[3,] = ICnorm\n    \n    outprint = round(outprint,2)\n    \n    outprint2 = round(c(summary(qvet), sd(qvet)),2)\n    names(outprint2) = c(names(summary(0)), 'dev std')\n    \n    if (input$dtab == 'distribuzione'){\n      output$DIST = renderPrint({outprint2})\n    }else{\n      output$DIST = renderPrint({outprint})\n    }\n    \n    legend(\"topright\", \n           c('media','mediana (quantile 50%)','quantili 25% e 75%', \n             'densità kernel', 'densità poisson', 'densità normale'), \n           col=c('red', 'orange','green','blue','darkred', 'purple'), lwd=2)\n  })\n  \n  \n}\n\n\n# Create Shiny app ----\nshinyApp(ui = ui, server = server)","type":"text"}]
